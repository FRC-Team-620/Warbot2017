// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc620.Warbot2017;

import edu.wpi.cscore.CvSink;
import edu.wpi.cscore.CvSource;
import edu.wpi.cscore.UsbCamera;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import org.opencv.core.Mat;
import org.usfirst.frc620.Warbot2017.commands.*;
import org.usfirst.frc620.Warbot2017.subsystems.*;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot {

	Command autonomousCommand;

	public static OI oi;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public static DriveTrain driveTrain;
	public static Climber climber;
	public static GearArm gearArm;
	public static BallMech ballMech;
	public static Lidar lidar;
	public static NavX navX;
	public static Vision vision;
	public static DriveWithXbox DriveWithXbox;

	public static int NUMBER_OF_CAMERAS = 0;
	private static UsbCamera[] cameras;
	private static CvSink[] cvs;
	private CvSource outputStream;
	private Mat frame;
	private static int camera = 0;
	private XboxController xbox = oi.getxbox();
	ButtonReader test = new ButtonReader(1);

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	/**
	 * This function is run when the robot is first started up and should be
	 * used for any initialization code.
	 */
	public void robotInit() {
		RobotMap.init();
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		driveTrain = new DriveTrain();
		climber = new Climber();
		gearArm = new GearArm();
		ballMech = new BallMech();
		lidar = new Lidar();
		navX = new NavX();
		vision = new Vision();
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		// OI must be constructed after subsystems. If the OI creates Commands
		// (which it very likely will), subsystems are not guaranteed to be
		// constructed yet. Thus, their requires() statements may grab null
		// pointers. Bad news. Don't move it.
		oi = new OI();

		// CameraServer.getInstance().startAutomaticCapture();
		// instantiate the command used for the autonomous period
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

		autonomousCommand = new AutonomousCommand();

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

		if (NUMBER_OF_CAMERAS > 0) {
			cameras = new UsbCamera[NUMBER_OF_CAMERAS];
			cvs = new CvSink[NUMBER_OF_CAMERAS];
			int backTake = 0;
			for (int i = 0; i < NUMBER_OF_CAMERAS; i++) {
				cameras[i - backTake] = CameraServer.getInstance().startAutomaticCapture();
				// if(cameras[i - backTake].isConnected())
				// {
				// backTake ++;
				// NUMBER_OF_CAMERAS --;
				// }
				CameraServer.getInstance().removeServer("USB Camera " + i);
				cameras[i - backTake].setResolution(320, 240);
				cvs[i - backTake] = CameraServer.getInstance().getVideo(cameras[i]);
				cvs[i - backTake].setEnabled(false);
			}
			outputStream = CameraServer.getInstance().putVideo("Camera Stream", 320, 240);
			frame = new Mat();

			new Thread(() -> {
				while (!Thread.interrupted()) {
					cvs[camera].grabFrame(frame);
					outputStream.putFrame(frame);
				}
			}).start();
		}
	}

	public static int getCurrentCam() {
		return camera;
	}

	public static void nextCamera() {
		switchToCamera((camera + 1) % NUMBER_OF_CAMERAS);
	}

	public static void lastCamera() {
		switchToCamera((camera + NUMBER_OF_CAMERAS - 1) % NUMBER_OF_CAMERAS);
	}

	public static void switchToCamera(int cam) {
		camera = cam;
	}

	public static void darkenCamera(int cam) {
		UsbCamera camera = cameras[cam];
		camera.setWhiteBalanceManual(0);
		camera.setExposureManual(0);
	}

	public static void brightenCamera(int cam) {
		UsbCamera camera = cameras[cam];
		camera.setWhiteBalanceAuto();
		camera.setExposureAuto();
	}

	/**
	 * This function is called when the disabled button is hit. You can use it
	 * to reset subsystems before shutting down.
	 */
	public void disabledInit() {

	}

	public void disabledPeriodic() {
		Scheduler.getInstance().run();
	}

	public void autonomousInit() {
		// schedule the autonomous command (example)
		if (autonomousCommand != null)
			autonomousCommand.start();
	}

	/**
	 * This function is called periodically during autonomous
	 */
	public void autonomousPeriodic() {
		Scheduler.getInstance().run();
	}

	public void teleopInit() {
		// This makes sure that the autonomous stops running when
		// teleop starts running. If you want the autonomous to
		// continue until interrupted by another command, remove
		// this line or comment it out.
		if (autonomousCommand != null)
			autonomousCommand.cancel();
	}

	/**
	 * This function is called periodically during operator control
	 */
	public void teleopPeriodic() {
		Scheduler.getInstance().run();
	}

	//-----------TEST MODE STUFF------------//
	
	private int testPhase = -1;
	private long timer = 0;
	private boolean toggle = false;
	
	@Override
	public void testInit() {
		System.out.println("Starting test mode. Ensure that the robot has plenty of space around it, and then press A to continue through the phases of the test.");
	}

	/**
	 * This function is called periodically during test mode
	 */
	public void testPeriodic() {
		LiveWindow.run();
		test.update(xbox);
		if (test.pressed()) {
			testPhase++;

			switch (testPhase) {
			case 0:
				System.out.println("This is the basic drive test. The robot should be moving back and forth.");
				break;
			case 1:
				System.out.println("This is the turning test. The robot should be rotating left and right.");
				break;
			case 2:
				System.out.println("This is the straffe test. The robot should be straffing left and right.");
				break;
			case 3:
				if(NUMBER_OF_CAMERAS > 0)
					System.out.println("There are no connected cameras to test, press A to skip this phase.");
				else
					System.out.println("This is the camera test. The drive station should be cycling through available cameras.");
				break;
			case 4:
				System.out.println("This is the LIDAR test. Verify that the values shown match proper LIDAR values.");
				break;
			default:
				break;
			}
		}
		if ( System.currentTimeMillis() - timer >= 500) {
			toggle = !toggle;
			timer = System.currentTimeMillis();
			switch (testPhase) {
			case 0:
				Robot.driveTrain.mecanumDrive(toggle ? .5 : -.5, 0, 0, 0);
				break;
			case 1:
				Robot.driveTrain.mecanumDrive(0, toggle ? .5 : -.5, 0, 0);
				break;
			case 2:
				Robot.driveTrain.mecanumDrive(0, 0, toggle ? .5 : -.5, 0);
				break;
			case 3:
				if(NUMBER_OF_CAMERAS > 0)
					nextCamera();
				break;
			case 4:
				System.out.println(lidar.getDistanceInches() + " inches");
				break;
			default:
				break;
			}
		}

	}
}
